########################################################################
# THIS FILE IS PART OF Planter PROJECT
# Copyright (c) Changgang Zheng and Computing Infrastructure Lab
# Departement of Engineering Science, University of Oxford
# All rights reserved.
# E-mail: changgang.zheng@eng.ox.ac.uk or changgangzheng@qq.com
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at :
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#########################################################################
# This file was autogenerated

/*
 * Planter
 *
 * This program implements a simple protocol. It can be carried over Ethernet
 * (Ethertype 0x1234).
 *
 * The Protocol header looks like this:
 *
 *        0                1                  2              3
 * +----------------+----------------+----------------+---------------+
 * |      P         |       4        |     Version    |     Type      |
 * +----------------+----------------+----------------+---------------+
 * |                              feature0                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature1                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature2                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature3                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature4                            |
 * +----------------+----------------+----------------+---------------+
 * |                              Result                              |
 * +----------------+----------------+----------------+---------------+
 *
 * P is an ASCII Letter 'P' (0x50)
 * 4 is an ASCII Letter '4' (0x34)
 * Version is currently 1 (0x01)
 * Type is currently 1 (0x01)
 *
 * The device receives a packet, do the classification, fills in the
 * result and sends the packet back out of the same port it came in on, while
 * swapping the source and destination addresses.
 *
 * If an unknown operation is specified or the header is not valid, the packet
 * is dropped
 */

#include <core.p4>
#include <v1model.p4>

/*************************************************************************
*********************** headers and metadata *****************************
*************************************************************************/

typedef bit<48> mac_addr_t;
typedef bit<32> ipv4_addr_t;
typedef bit<9> egressSpec_t;
const bit<16> ETHERTYPE_TPID = 0x8100;
const bit<16> ETHERTYPE_IPV4 = 0x0800;
const bit<16> ETHERTYPE_ARP = 0x0806;
typedef bit<8> ip_protocol_t;
const ip_protocol_t IP_PROTOCOLS_UDP = 17;
const bit<8> UDP_TYPE = 0x11;
const bit<8> TCP_TYPE = 0x06;
const int IPV4_HOST_TABLE_SIZE = 65536;
// const bit<16> ETHERTYPE_Planter = 0x1234;

// for flows
#define IAT 24
#define PACKET_LENGTH 32
#define FLAGS 8
#define PACKET_NUM 16
#define BUCKET_LENGTH 16
#define FLOW_ENTRY_WIDTH 369
#define FLOW_ID_BIT_WIDTH 32
#define TIMEOUT_VALUE 42
#define ETHERNET_LENGTH 14
#define IPV4_LENGTH 20
#define UDP_LENGTH 8

header ethernet_h {
    mac_addr_t dst_addr;
    mac_addr_t src_addr;
    bit<16> ether_type;
}

header ipv4_h {
    bit<4> version;
    bit<4> ihl;
    bit<8> diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3> flags;
    bit<13> frag_offset;
    bit<8> ttl;
    bit<8> protocol;
    bit<16> hdr_checksum;
    ipv4_addr_t src_addr;
    ipv4_addr_t dst_addr;
}

header l4_ports_t {
    bit<16>   l4_srcPort;
    bit<16>   l4_dstPort;
    }
header udp_h{
    bit<16> hdr_length;
    bit<16> checksum;
}

header tcp_h{
    int<32> seqNo;
    int<32> ackNo;
    bit<4> data_offset;
    // bit<3>  res;
    // bit<3>  ecn;        //Explicit congestion notification
    // bit<6>  ctrl;       // URG,ACK,PSH,RST,SYN,FIN
    bit<4>  res;
    bit<1>  cwr;
    bit<1>  ece;
    bit<1>  urg;
    bit<1>  ack;
    bit<1>  psh;
    bit<1>  rst;
    bit<1>  syn;
    bit<1>  fin;
    bit<16> window;
    bit<16> checksum;
    bit<16> urgentPtr;
}

header arp_h{
    bit<16> hwType;
    bit<16> protoType;
    bit<8> hwAddrLen;
    bit<8> protoAddrLen;
    bit<16> opcode;
    bit<48> hwSrcAddr;
    bit<32> protoSrcAddr;
    bit<48> hwDstAddr;
    bit<32> protoDstAddr;
}

header vlan_tag_h{
    bit<3> pcp;
    bit<1> dei;
    bit<12> vid;
    bit<16> ether_type;
    }

// header Planter_h{
//     bit<8> p;
//     bit<8> four;
//     bit<8> ver;
//     bit<8> typ;
//     bit<32> feature0;
//     bit<32> feature1;
//     bit<32> feature2;
//     bit<32> feature3;
//     bit<32> feature4;
//     bit<32> result;
// }

struct header_t {
    ethernet_h   ethernet;
    vlan_tag_h   vlan_tag;
    ipv4_h       ipv4;
    arp_h        arp;
    // Planter_h    Planter;
    l4_ports_t   l4_ports;
    tcp_h        tcp;
    udp_h        udp;
}

struct int_cpu_digest_t
    {
    	bit<32> ip_src;
    	bit<32> ip_dst;
    	bit<32> feature0;
        bit<32> feature1;
        bit<32> feature2;
    	bit<32> feature3;
    	bit<32> feature4;
    	bit<4>  malware;
    	bit<4>  class;
    }


typedef struct flow_features {
    bit<IAT> flow_duration;
    bit<IAT> flow_IAT_mean;
    bit<IAT> flow_IAT_max;
    bit<IAT> flow_IAT_min;
    bit<PACKET_LENGTH> min_packet_length;
    bit<PACKET_LENGTH> max_packet_length;
    bit<PACKET_LENGTH> packet_length_mean;
    bit<PACKET_LENGTH> total_packet_length;
    bit<PACKET_NUM> packets_number;
    bit<FLAGS> fin_flag_count;
    bit<FLAGS> syn_flag_count;
    bit<FLAGS> rst_flag_count;
    bit<FLAGS> psh_flag_count;
    bit<FLAGS> ack_flag_count;
    bit<FLAGS> ece_flag_count;
} flow_features_t;

// for flow
typedef struct flow_entry{
    bit<1>  used;
    bit<32> flow_id;
    bit<48> timestamp;
    flow_features_t flow_features;
} flow_entry_t;


struct metadata_t {
    bit<1> code_f0;
    bit<1> code_f1;
    bit<1> code_f2;
    bit<2> code_f3;
    bit<2> code_f4;
    bit<7> sum_prob;
    bit<32>  DstAddr;
    bit<32> feature0;
    bit<32> feature1;
    bit<32> feature2;
    bit<32> feature3;
    bit<32> feature4;
    bit<32> srcip;
    bit<32> dstip;
    bit<32> result;
    bit<32> class;
    bit<4> malware;
    bit<1> send_int_cpu_digest;
    bit<8> flag ;
    // for flow
    bit<4> index_table0;
    bit<4> index_table1;
    bit<1> usable0;
    bit<1> usable1;
    flow_entry_t flow;
    bit<48> current_timestamp;
    bit<32> current_flow_id;
    bit<1> found_entry;
    bit<FLOW_ENTRY_WIDTH> bitstring;
    
    bit<2> meter_color;
    bit<2> meter_tag;
}



/*************************************************************************
*********************** Ingress Parser ***********************************
*************************************************************************/

parser SwitchParser(
    packet_in pkt,
    out header_t hdr,
    inout metadata_t meta,
    inout standard_metadata_t ig_intr_md) {

    state start {
        transition parse_ethernet;
    }

    state parse_ethernet {
        pkt.extract(hdr.ethernet);
        transition select(hdr.ethernet.ether_type) {
            ETHERTYPE_TPID:  parse_vlan_tag;
            ETHERTYPE_IPV4:  parse_ipv4;
            ETHERTYPE_ARP:  parse_arp;
            // ETHERTYPE_Planter:  parse_Planter;
            default: accept;
        }
    }

    state parse_vlan_tag {
        pkt.extract(hdr.vlan_tag);
        transition select(hdr.vlan_tag.ether_type) {
            ETHERTYPE_IPV4:  parse_ipv4;
            // ETHERTYPE_Planter:  parse_Planter;
            default: accept;
        }
    }

    // state parse_Planter {
    //     pkt.extract(hdr.Planter);
    //     transition accept;
    // }

    state parse_ipv4 {
        pkt.extract(hdr.ipv4);
        meta.srcip = (bit<32>) hdr.ipv4.src_addr;
        meta.dstip = (bit<32>) hdr.ipv4.dst_addr;
        // meta.feature0 = (bit<32>)(bit<8>) hdr.ipv4.src_addr;
        // meta.feature1 = (bit<32>)(bit<8>) hdr.ipv4.dst_addr;
        transition select(hdr.ipv4.protocol) {
            UDP_TYPE:  parse_udp_ports;
            TCP_TYPE:  parse_tcp_ports;
            default: accept;
        }
    }

    state parse_arp {
        pkt.extract(hdr.arp);
        transition accept;
    }

    state parse_tcp_ports{
        pkt.extract(hdr.l4_ports);
        // meta.feature2 = (bit < 32 >)hdr.l4_ports.l4_srcPort;
        // meta.feature3 = (bit < 32 >)hdr.l4_ports.l4_dstPort;
        transition parse_tcp;
    }
    state parse_udp_ports{
        pkt.extract(hdr.l4_ports);
        // meta.feature2 = (bit < 32 >)hdr.l4_ports.l4_srcPort;
        // meta.feature3 = (bit < 32 >)hdr.l4_ports.l4_dstPort;
        transition parse_udp;
    }
    state parse_udp {
        pkt.extract(hdr.udp);
        transition accept;
    }

    state parse_tcp {
        pkt.extract(hdr.tcp);
        // meta.feature4 = (bit<32>)hdr.tcp.ctrl;
        transition accept;
    }

}

/*************************************************************************
*********************** Egress Deparser *********************************
**************************************************************************/

control SwitchDeparser(
    packet_out pkt,
    in header_t hdr) {
    apply {
        pkt.emit(hdr);
    }
}

/*************************************************************************
********************** Checksum Verification *****************************
*************************************************************************/

control SwitchVerifyChecksum(inout header_t hdr,
                       inout metadata_t meta) {
    apply {}
}
/*************************************************************************
********************** Checksum Computation ******************************
*************************************************************************/

control SwitchComputeChecksum(inout header_t hdr,
                        inout metadata_t meta) {
    apply {}
}
/*************************************************************************
*********************** Ingress Processing********************************
**************************************************************************/

control SwitchIngress(
    inout header_t hdr,
    inout metadata_t meta,
    inout standard_metadata_t ig_intr_md) {
    
    // refer to: https://gitlab.ethz.ch/nsg/public/adv-net-2020/-/blob/master/03-RSVP/solution/rsvp.p4
    /* Direct meter*/
    //direct_meter<bit<2>>(MeterType.bytes) rsvp_meter;
    meter(2, MeterType.packets) rsvp_meter;

    // flow
    register<bit<FLOW_ENTRY_WIDTH>>(BUCKET_LENGTH) flows0;
    register<bit<FLOW_ENTRY_WIDTH>>(BUCKET_LENGTH) flows1;

    action struct2bitstring() {
        bit<FLOW_ENTRY_WIDTH> bitstring = meta.flow.flow_features.ece_flag_count ++
                                        meta.flow.flow_features.ack_flag_count ++
                                        meta.flow.flow_features.psh_flag_count ++
                                        meta.flow.flow_features.rst_flag_count ++
                                        meta.flow.flow_features.syn_flag_count ++
                                        meta.flow.flow_features.fin_flag_count ++
                                        meta.flow.flow_features.packets_number ++
                                        meta.flow.flow_features.total_packet_length ++
                                        meta.flow.flow_features.packet_length_mean ++
                                        meta.flow.flow_features.max_packet_length ++
                                        meta.flow.flow_features.min_packet_length ++
                                        meta.flow.flow_features.flow_IAT_min ++
                                        meta.flow.flow_features.flow_IAT_max ++
                                        meta.flow.flow_features.flow_IAT_mean ++
                                        meta.flow.flow_features.flow_duration ++
                                        meta.flow.timestamp ++
                                        meta.flow.flow_id ++
                                        meta.flow.used;

        meta.bitstring = bitstring;
    }

    // Utility action to convert a bitstring into our flow_entry struct
    // refer to pforest
    action bitstring2struct(){
        meta.flow.used = meta.bitstring[0:0];
        meta.flow.flow_id = meta.bitstring[32:1];
        meta.flow.timestamp = meta.bitstring[80:33];
        const int sindex = 81;
        meta.flow.flow_features.flow_duration= meta.bitstring[sindex+IAT-1:sindex];
        const int sindex2 = sindex + IAT;
        meta.flow.flow_features.flow_IAT_mean = meta.bitstring[sindex2 + IAT-1:sindex2];
        const int sindex3 = sindex2 + IAT;
        meta.flow.flow_features.flow_IAT_max = meta.bitstring[sindex3 + IAT-1:sindex3];
        const int sindex4 = sindex3 + IAT;
        meta.flow.flow_features.flow_IAT_min = meta.bitstring[sindex4 + IAT-1:sindex4];
        const int sindex5 = sindex4 + IAT;
        meta.flow.flow_features.min_packet_length = meta.bitstring[sindex5 + PACKET_LENGTH-1:sindex5];
        const int sindex6 = sindex5 + PACKET_LENGTH;
        meta.flow.flow_features.max_packet_length = meta.bitstring[sindex6 + PACKET_LENGTH-1:sindex6];
        const int sindex7 = sindex6 + PACKET_LENGTH;
        meta.flow.flow_features.packet_length_mean = meta.bitstring[sindex7 + PACKET_LENGTH-1:sindex7];
        const int sindex8 = sindex7 + PACKET_LENGTH;
        meta.flow.flow_features.total_packet_length = meta.bitstring[sindex8 + PACKET_LENGTH-1:sindex8];
        const int sindex9 = sindex8 + PACKET_LENGTH;
        meta.flow.flow_features.packets_number = meta.bitstring[sindex9 + PACKET_NUM-1:sindex9];
        const int sindex10 = sindex9 + PACKET_NUM;
        meta.flow.flow_features.fin_flag_count = meta.bitstring[sindex10 + FLAGS-1:sindex10];
        const int sindex11 = sindex10 + FLAGS;
        meta.flow.flow_features.syn_flag_count = meta.bitstring[sindex11 + FLAGS-1:sindex11];
        const int sindex12 = sindex11 + FLAGS;
        meta.flow.flow_features.rst_flag_count = meta.bitstring[sindex12 + FLAGS-1:sindex12];
        const int sindex13 = sindex12 + FLAGS;
        meta.flow.flow_features.psh_flag_count = meta.bitstring[sindex13 + FLAGS-1:sindex13];
        const int sindex14 = sindex13 + FLAGS;
        meta.flow.flow_features.ack_flag_count = meta.bitstring[sindex14 + FLAGS-1:sindex14];
        const int sindex15 = sindex14 + FLAGS;
        meta.flow.flow_features.ece_flag_count = meta.bitstring[sindex15 + FLAGS-1:sindex15];
    }

    // Init flow feature
    action init_flow_features() {
        meta.flow.flow_features.flow_duration = 0;

        // IAT
        meta.flow.flow_features.flow_IAT_mean = 0;
        meta.flow.flow_features.flow_IAT_min = 0;
        meta.flow.flow_features.flow_IAT_max = 0;

        // packet_length
        // We just want the payload: hence, we subtracts the headers bytes
        bit<PACKET_LENGTH> packet_length = ig_intr_md.packet_length - ETHERNET_LENGTH - IPV4_LENGTH;
        if (hdr.ipv4.protocol == TCP_TYPE) {
            packet_length = packet_length - ((bit<PACKET_LENGTH>)hdr.tcp.data_offset*4);
        } else {
            packet_length = packet_length - UDP_LENGTH;
        }
        meta.flow.flow_features.min_packet_length = packet_length;
        meta.flow.flow_features.max_packet_length = packet_length;
        meta.flow.flow_features.packet_length_mean = packet_length;
        meta.flow.flow_features.total_packet_length = packet_length;

        // TCP Flag counts
        if (hdr.ipv4.protocol == TCP_TYPE) {
            if (hdr.tcp.fin == 1) {
                meta.flow.flow_features.fin_flag_count = 1;
            } else {
                meta.flow.flow_features.fin_flag_count = 0;
            }

            if (hdr.tcp.syn == 1) {
                meta.flow.flow_features.syn_flag_count = 1;
            } else {
                meta.flow.flow_features.syn_flag_count = 0;
            }

            if (hdr.tcp.rst == 1) {
                meta.flow.flow_features.rst_flag_count = 1;
            } else {
                meta.flow.flow_features.rst_flag_count = 0;
            }

            if (hdr.tcp.psh == 1) {
                meta.flow.flow_features.psh_flag_count = 1;
            } else {
                meta.flow.flow_features.psh_flag_count = 0;
            }

            if (hdr.tcp.ack == 1) {
                meta.flow.flow_features.ack_flag_count = 1;
            } else {
                meta.flow.flow_features.ack_flag_count = 0;
            }

            if (hdr.tcp.ece == 1) {
                meta.flow.flow_features.ece_flag_count = 1;
            } else {
                meta.flow.flow_features.ece_flag_count = 0;
            }
        } else {
            meta.flow.flow_features.fin_flag_count = 0;
            meta.flow.flow_features.syn_flag_count = 0;
            meta.flow.flow_features.rst_flag_count = 0;
            meta.flow.flow_features.ack_flag_count = 0;
            meta.flow.flow_features.psh_flag_count = 0;
            meta.flow.flow_features.ece_flag_count = 0;
        }

        // packet number
        meta.flow.flow_features.packets_number = 1;
    }

    action init_flow_entry() {
        meta.flow.used = 1;
        meta.flow.flow_id = meta.current_flow_id;
        init_flow_features();
        meta.flow.timestamp = meta.current_timestamp;
    }

    // update flow feature
    action update_flow_features() {
        // Packet number
        meta.flow.flow_features.packets_number = meta.flow.flow_features.packets_number + 1;

        // Packet length updates
        // We just want the payload: hence, we subtracts the headers bytes
        bit<PACKET_LENGTH> packet_length = ig_intr_md.packet_length - ETHERNET_LENGTH - IPV4_LENGTH;
        if (hdr.ipv4.protocol == TCP_TYPE) {
            packet_length = packet_length - ((bit<PACKET_LENGTH>)hdr.tcp.data_offset*4);
        } else {
            packet_length = packet_length - UDP_LENGTH;
        }
        if(packet_length > meta.flow.flow_features.max_packet_length){
            meta.flow.flow_features.max_packet_length = packet_length;
        }
        if(packet_length < meta.flow.flow_features.min_packet_length){
            meta.flow.flow_features.min_packet_length = packet_length;
        }
        meta.flow.flow_features.total_packet_length = meta.flow.flow_features.total_packet_length + packet_length;

        bit<PACKET_LENGTH> old_length_mean = meta.flow.flow_features.packet_length_mean;
        meta.flow.flow_features.packet_length_mean = (old_length_mean + packet_length) >> 1;   // moving average

        // IAT updates
        bit<IAT> IAT_value = (bit<IAT>) (meta.current_timestamp - meta.flow.timestamp);
        if (IAT_value > meta.flow.flow_features.flow_IAT_max){
            meta.flow.flow_features.flow_IAT_max = IAT_value;
        }
        if (meta.flow.flow_features.packets_number == 2) {
            meta.flow.flow_features.flow_IAT_min = IAT_value;
        } else {
            if (IAT_value < meta.flow.flow_features.flow_IAT_min){
                meta.flow.flow_features.flow_IAT_min = IAT_value;
            }
        }
        bit<IAT> old_IAT_mean = meta.flow.flow_features.flow_IAT_mean;
        meta.flow.flow_features.flow_IAT_mean = (old_IAT_mean + IAT_value) >> 1;     // moving average

        meta.flow.flow_features.flow_duration = meta.flow.flow_features.flow_duration + IAT_value;

        // TCP Flag counts
        if (hdr.ipv4.protocol == TCP_TYPE) {
            if (hdr.tcp.fin == 1) {
                meta.flow.flow_features.fin_flag_count =  meta.flow.flow_features.fin_flag_count + 1;
            }

            if (hdr.tcp.syn == 1) {
                meta.flow.flow_features.syn_flag_count =  meta.flow.flow_features.syn_flag_count + 1;
            }

            if (hdr.tcp.rst == 1) {
                meta.flow.flow_features.rst_flag_count =  meta.flow.flow_features.rst_flag_count + 1;
            }

            if (hdr.tcp.psh == 1) {
                meta.flow.flow_features.psh_flag_count =  meta.flow.flow_features.psh_flag_count + 1;
            }

            if (hdr.tcp.ack == 1) {
                meta.flow.flow_features.ack_flag_count =  meta.flow.flow_features.ack_flag_count + 1;
            }

            if (hdr.tcp.ece == 1) {
                meta.flow.flow_features.ece_flag_count =  meta.flow.flow_features.ece_flag_count + 1;
            }
        }
    }

    action update_flow_entry(){
        update_flow_features();
        meta.flow.timestamp = meta.current_timestamp;
    }

    action send(bit<9> port) {
        ig_intr_md.egress_spec = port;
    }

    action drop() {
        mark_to_drop(ig_intr_md);
    }

    counter(1, CounterType.packets) counter_true_attack;
    counter(1, CounterType.packets) counter_false_attack;
    counter(1, CounterType.packets) counter_false_benign;
    counter(1, CounterType.packets) counter_true_benign;

    action ipv4_forward(mac_addr_t dstAddr, egressSpec_t port) {
        send(port);
        hdr.ethernet.src_addr = hdr.ethernet.dst_addr;
        hdr.ethernet.dst_addr = dstAddr;
        hdr.ipv4.ttl = hdr.ipv4.ttl - 1;
    }
    
    action m_action ( bit <32 > meter_id ) {
	rsvp_meter.execute_meter (( bit <32 >) meter_id, meta.meter_tag ) ;
    }
    
    table meter_table {
	key = {
	    meta.meter_color: exact ;
	}
    	actions = {
		m_action ;
		NoAction ;
	}
	size = 1024;
	default_action = NoAction () ;
	}

    table meter_filter {
	 key = {
 	meta.meter_tag : exact ;
 	}
 	actions = {
 	drop ;
 	NoAction ;
  	}
	 
	size = 1024;
 	default_action = drop () ;
	}


    table decision_mitigation {
        key = {
            meta.result: exact;
        }
        actions={
            //metering;
            drop;
        }
        size = 4;
        default_action = drop();
    }

    table fwd_tb {
    key = {
        hdr.ipv4.dst_addr : lpm;
    }
    actions = {
        ipv4_forward;
        drop;
        NoAction;
    }
    default_action = drop;
    }

    action SetMalware(bit<4> malware_flag) {
    meta.malware = malware_flag;
    }

    table malware{
    key = {
        hdr.ipv4.src_addr: lpm;
        }
        actions = {
        NoAction;
        SetMalware;
        }
        size = 10;
        default_action = NoAction();
        }

    table malware_inverse {
    key = {
        hdr.ipv4.dst_addr: lpm;
     }
     actions = {
               NoAction;
               SetMalware;
      }
      size = 10;
      default_action = NoAction();
      }

    action extract_feature0(out bit<1> meta_code, bit<1> tree){
        meta_code = tree;
    }

    action extract_feature1(out bit<1> meta_code, bit<1> tree){
        meta_code = tree;
    }

    action extract_feature2(out bit<1> meta_code, bit<1> tree){
        meta_code = tree;
    }

    action extract_feature3(out bit<2> meta_code, bit<2> tree){
        meta_code = tree;
    }

    action extract_feature4(out bit<2> meta_code, bit<2> tree){
        meta_code = tree;
    }

    action read_lable(bit<32> label){
        meta.result = label;
    }

    table lookup_feature0 {
        key = { meta.feature0:ternary; }
        actions = {
            extract_feature0(meta.code_f0);
            NoAction;
            }
        size = 17;
        default_action = NoAction;
    }

    table lookup_feature1 {
        key = { meta.feature1:ternary; }
        actions = {
            extract_feature1(meta.code_f1);
            NoAction;
            }
        size = 17;
        default_action = NoAction;
    }

    table lookup_feature2 {
        key = { meta.feature2:ternary; }
        actions = {
            extract_feature2(meta.code_f2);
            NoAction;
            }
        size = 6;
        default_action = NoAction;
    }

    table lookup_feature3 {
        key = { meta.feature3:ternary; }
        actions = {
            extract_feature3(meta.code_f3);
            NoAction;
            }
        size = 13;
        default_action = NoAction;
    }

    table lookup_feature4 {
        key = { meta.feature4:ternary; }
        actions = {
            extract_feature4(meta.code_f4);
            NoAction;
            }
        size = 12;
        default_action = NoAction;
    }

    action write_default_class() {
        meta.result = 0;
    }

    table decision {
        key = { meta.code_f0[0:0]:exact;
                meta.code_f1[0:0]:exact;
                meta.code_f2[0:0]:exact;
                meta.code_f3[1:0]:exact;
                meta.code_f4[1:0]:exact;
                }
        actions={
            read_lable;
            write_default_class;
        }
        size = 1;
        default_action = write_default_class;
    }

    apply{
        // flow feature collections
        // Set flow ID
        // 1st hash to compute the flow ID
        hash(meta.current_flow_id,
            HashAlgorithm.crc32,
            (bit<16>)0,
            {hdr.ipv4.src_addr,hdr.ipv4.dst_addr,hdr.l4_ports.l4_srcPort,hdr.l4_ports.l4_dstPort, hdr.ipv4.protocol},
            (bit<32>)4294967295);

        // Set current timestamp
        meta.current_timestamp = ig_intr_md.ingress_global_timestamp;

        /*******************************************************************
         **************** I N D E X  C A L C U L A T I O N S ***************
         *******************************************************************/

        // hash0
        hash(meta.index_table0,
            HashAlgorithm.crc32_custom,
            (bit<16>)0,
            {meta.current_flow_id},
            (bit<32>)BUCKET_LENGTH);

        // hash1
        hash(meta.index_table1,
            HashAlgorithm.crc32_custom,
            (bit<16>)0,
            {meta.current_flow_id},
            (bit<32>)BUCKET_LENGTH);

        // (.... continue with next hashes if needed)

        // Finding phase
        meta.found_entry = 0;
        meta.usable0 = 0;
        meta.usable1 = 0;

        // Find a match: find existing flow:

        // For each register : read flow contained at index and check whether match
        if(meta.found_entry == 0){
            // read the flow entry
            flows0.read(meta.bitstring,(bit<32>)meta.index_table0);
            bitstring2struct();

            // check if entry is used already
            if(meta.flow.used == 1) {
                // check if flow id matches
                if(meta.flow.flow_id == meta.current_flow_id){
                    // match found => update the features and tag flow as found
                    meta.found_entry = 1;
                    update_flow_entry();
                    struct2bitstring();
                    flows0.write((bit<32>)meta.index_table0,meta.bitstring);
                } else {
                    // no match, check if entry is still usable
                    if(meta.current_timestamp - meta.flow.timestamp > TIMEOUT_VALUE){
                        meta.usable0 = 1;
                    }
                }
            } else {
                // entry is not used : mark it as usable
                meta.usable0 = 1;
            }
        }

        // If no match found continue to next register:

        if(meta.found_entry == 0){
            // read the flow entry
            flows1.read(meta.bitstring,(bit<32>)meta.index_table1);
            bitstring2struct();

            // check if entry is used already
            if(meta.flow.used == 1) {
                // check if flow id matches
                if(meta.flow.flow_id == meta.current_flow_id){ // same here, we should update all of them accordingly: if here we have the same flowID, in all of the other tables we should have matching flowID!
                    // match found => update the features and tag flow as found
                    meta.found_entry = 1;
                    update_flow_entry();
                    struct2bitstring();
                    flows1.write((bit<32>)meta.index_table1,meta.bitstring);
                } else {
                    // no match, check if entry is still usable
                    if(meta.current_timestamp - meta.flow.timestamp > TIMEOUT_VALUE){
                        meta.usable1 = 1;
                    }
                }
            } else {
                // entry is not used : mark it as usable
                meta.usable1 = 1;
            }
        }

        if(meta.found_entry == 0 && meta.usable0 == 1){
            meta.found_entry = 1;
            init_flow_entry();
            struct2bitstring();
            flows0.write((bit<32>)meta.index_table0,meta.bitstring);
        }

        if(meta.found_entry == 0 && meta.usable1 == 1){
            meta.found_entry = 1;
            init_flow_entry();
            struct2bitstring();
            flows1.write((bit<32>)meta.index_table1,meta.bitstring);
        }

        meta.feature0 = (bit<32>)meta.flow.flow_features.flow_duration;
        meta.feature1 = (bit<32>)meta.flow.flow_features.flow_IAT_mean;
        meta.feature2 = (bit<32>)meta.flow.flow_features.flow_IAT_max;
        meta.feature3 = (bit<32>)meta.flow.flow_features.flow_IAT_min;
        meta.feature4 = (bit<32>)meta.flow.flow_features.min_packet_length;


        // tree logics
        lookup_feature0.apply();
        lookup_feature1.apply();
        lookup_feature2.apply();
        lookup_feature3.apply();
        lookup_feature4.apply();
        decision.apply();
        malware.apply();
        malware_inverse.apply();
        meter_table.apply();
        meter_filter.apply();
        if (meta.malware != 0) {// meta.malware is calculated with priori knowledge for statistics
             if(meta.result == (bit<32>)meta.malware) {
                counter_true_attack.count(0);
        		decision_mitigation.apply();

            } else {
                counter_false_attack.count(0);// malicious flows but not detected as the exact type
            }
            
         }
         else {
            if(meta.result == 0) {
                counter_true_benign.count(0);
        		fwd_tb.apply();
            } else {
                counter_false_benign.count(0);
            }
        }
	
        digest<int_cpu_digest_t>(1, {hdr.ipv4.src_addr, hdr.ipv4.dst_addr, meta.feature0, meta.feature1, meta.feature2, meta.feature3, meta.feature4, (bit<4>)meta.malware, (bit<4>)meta.result});
    }
}
/*************************************************************************
*********************** egress Processing********************************
**************************************************************************/

control SwitchEgress(inout header_t hdr,
    inout metadata_t meta,
    inout standard_metadata_t eg_intr_md) {
    apply {
    }
}
/*************************************************************************
***********************  S W I T C H  ************************************
*************************************************************************/

V1Switch(
    SwitchParser(),
    SwitchVerifyChecksum(),
    SwitchIngress(),
    SwitchEgress(),
    SwitchComputeChecksum(),
    SwitchDeparser()
) main;
